/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Modified for intelligent pathfinding behavior
*/

import * as THREE from 'three';
import React, { useRef, useEffect, useState, useMemo, useCallback } from 'react';
import { useGLTF, useAnimations } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import { useGameStore } from '../../store/store';

export function WalkingCharacter(props) {
  const group = useRef();
  const { nodes, materials, animations } = useGLTF('/assets/characters/villager_walking/scene.gltf');
  const { actions } = useAnimations(animations, group);
  
  const buildLots = useGameStore((state) => state.buildLots);
  const lotPositions = useGameStore((state) => state.lotPositions);
  
  const currentPosition = useRef(new THREE.Vector3(0, 0, 0));
  const [currentWaypoint, setCurrentWaypoint] = useState(0);
  const [path, setPath] = useState([]);
  const [currentBuildingId, setCurrentBuildingId] = useState(null);
  const [targetBuildingId, setTargetBuildingId] = useState(null);
  const [isMoving, setIsMoving] = useState(false);
  const [idleTimer, setIdleTimer] = useState(0);
  const [visitedBuildings, setVisitedBuildings] = useState(new Set());
  
  const walkSpeed = 0.02;
  const rotationSpeed = 0.15;
  const idleDuration = 2;
  const buildingRadius = 1.5; // Collision radius around buildings
  
  // Get all building positions (only lots with buildings)
  const buildingPositions = useMemo(() => {
    const positions = [];
    Object.entries(buildLots).forEach(([id, lot]) => {
      if (lot.entity !== null && lotPositions[id]) {
        positions.push({
          id,
          x: lotPositions[id].x,
          z: lotPositions[id].z,
          entity: lot.entity,
        });
      }
    });
    return positions;
  }, [buildLots, lotPositions]);

  // Calculate if a point is too close to any building
  const isPointNearBuilding = useCallback((x, z, excludeBuildingIds = []) => {
    return buildingPositions.some(building => {
      if (excludeBuildingIds.includes(building.id)) return false;
      const dx = building.x - x;
      const dz = building.z - z;
      const distance = Math.sqrt(dx * dx + dz * dz);
      return distance < buildingRadius;
    });
  }, [buildingPositions, buildingRadius]);

  // Simple pathfinding - creates waypoints around obstacles
  const findPath = useCallback((startPos, endPos, startBuildingId, endBuildingId) => {
    const start = { x: startPos.x, z: startPos.z };
    const end = { x: endPos.x, z: endPos.z };
    
    // Direct line check
    const dx = end.x - start.x;
    const dz = end.z - start.z;
    const distance = Math.sqrt(dx * dx + dz * dz);
    const steps = Math.ceil(distance / 0.5);
    
    let hasObstacle = false;
    for (let i = 1; i < steps; i++) {
      const t = i / steps;
      const checkX = start.x + dx * t;
      const checkZ = start.z + dz * t;
      if (isPointNearBuilding(checkX, checkZ, [startBuildingId, endBuildingId])) {
        hasObstacle = true;
        break;
      }
    }
    
    // If no obstacle, go direct
    if (!hasObstacle) {
      return [
        new THREE.Vector3(start.x, 0, start.z),
        new THREE.Vector3(end.x, 0, end.z)
      ];
    }
    
    // If obstacle, create a waypoint to go around
    // Calculate perpendicular offset
    const midX = (start.x + end.x) / 2;
    const midZ = (start.z + end.z) / 2;
    const perpX = -(end.z - start.z);
    const perpZ = (end.x - start.x);
    const perpLen = Math.sqrt(perpX * perpX + perpZ * perpZ);
    const perpDist = 2.5;
    
    // Try offset in both directions
    const offset1X = midX + (perpX / perpLen) * perpDist;
    const offset1Z = midZ + (perpZ / perpLen) * perpDist;
    const offset2X = midX - (perpX / perpLen) * perpDist;
    const offset2Z = midZ - (perpZ / perpLen) * perpDist;
    
    let waypointX, waypointZ;
    if (!isPointNearBuilding(offset1X, offset1Z, [startBuildingId, endBuildingId])) {
      waypointX = offset1X;
      waypointZ = offset1Z;
    } else {
      waypointX = offset2X;
      waypointZ = offset2Z;
    }
    
    return [
      new THREE.Vector3(start.x, 0, start.z),
      new THREE.Vector3(waypointX, 0, waypointZ),
      new THREE.Vector3(end.x, 0, end.z)
    ];
  }, [isPointNearBuilding]);

  // Pick next building and calculate path
  const moveToNextBuilding = useCallback(() => {
    if (buildingPositions.length === 0) {
      console.warn('No buildings to navigate to');
      return;
    }
    
    // Find unvisited buildings
    const unvisited = buildingPositions.filter(b => !visitedBuildings.has(b.id));
    
    // If all buildings visited, reset and start over
    if (unvisited.length === 0) {
      setVisitedBuildings(new Set());
      console.log('Visited all buildings, restarting tour');
    }
    
    // Pick a random unvisited building (or any if reset)
    const availableBuildings = unvisited.length > 0 ? unvisited : buildingPositions;
    const targetBuilding = availableBuildings[Math.floor(Math.random() * availableBuildings.length)];
    
    // Mark as visited
    setVisitedBuildings(prev => new Set([...prev, targetBuilding.id]));
    
    // Calculate path
    const startPos = currentPosition.current;
    const endPos = new THREE.Vector3(targetBuilding.x, 0, targetBuilding.z);
    
    const newPath = findPath(startPos, endPos, currentBuildingId, targetBuilding.id);
    
    console.log(`Planning route to ${targetBuilding.entity} at (${targetBuilding.x}, ${targetBuilding.z})`);
    console.log(`Path has ${newPath.length} waypoints`);
    
    setPath(newPath);
    setCurrentWaypoint(1); // Start from waypoint 1 (0 is current position)
    setTargetBuildingId(targetBuilding.id);
    setIsMoving(true);
  }, [buildingPositions, visitedBuildings, currentBuildingId, findPath]);

  // Initialize character at first building
  useEffect(() => {
    if (buildingPositions.length > 0 && currentBuildingId === null) {
      const firstBuilding = buildingPositions[0];
      currentPosition.current.set(firstBuilding.x, 0, firstBuilding.z);
      if (group.current) {
        group.current.position.copy(currentPosition.current);
      }
      setCurrentBuildingId(firstBuilding.id);
      setVisitedBuildings(new Set([firstBuilding.id]));
      console.log(`Starting at ${firstBuilding.entity}`);
      
      // Start moving after a short delay
      setTimeout(() => {
        moveToNextBuilding();
      }, 1000);
    }
  }, [buildingPositions, currentBuildingId, moveToNextBuilding]);

  // Start the walking animation
  useEffect(() => {
    if (actions && actions['mixamo.com']) {
      const action = actions['mixamo.com'];
      action.reset();
      action.paused = true; // Start paused
      action.play();
      console.log('Animation system ready');
    }
  }, [actions]);

  const playIdleAnimation = useCallback(() => {
    if (actions && actions['mixamo.com']) {
      const action = actions['mixamo.com'];
      action.time = 0;
      action.paused = true;
      console.log('→ Idle');
    }
  }, [actions]);

  const playWalkAnimation = useCallback(() => {
    if (actions && actions['mixamo.com']) {
      const action = actions['mixamo.com'];
      action.paused = false;
      action.time = 0.5;
      console.log('→ Walking');
    }
  }, [actions]);

  useFrame((state, delta) => {
    if (!group.current) return;

    // Handle idle state
    if (!isMoving) {
      setIdleTimer(prev => {
        const newTimer = prev + delta;
        if (newTimer >= idleDuration) {
          // Idle time finished, start moving to next building
          playWalkAnimation();
          moveToNextBuilding();
          return 0;
        }
        return newTimer;
      });
      return;
    }

    // Moving state - follow waypoints
    if (currentWaypoint >= path.length) {
      // Reached final destination
      setCurrentBuildingId(targetBuildingId);
      setIsMoving(false);
      setIdleTimer(0);
      playIdleAnimation();
      console.log('Reached destination!');
      return;
    }

    const targetWaypoint = path[currentWaypoint];
    const direction = new THREE.Vector3()
      .subVectors(targetWaypoint, currentPosition.current)
      .normalize();
    
    const distance = currentPosition.current.distanceTo(targetWaypoint);
    
    if (distance > 0.1) {
      // Calculate movement step
      const step = walkSpeed;
      const moveDistance = Math.min(step, distance);
      
      // Move character
      currentPosition.current.add(direction.multiplyScalar(moveDistance));
      group.current.position.copy(currentPosition.current);
      
      // Calculate target rotation to face movement direction
      const desiredAngle = Math.atan2(direction.x, direction.z);
      
      // Get current rotation
      let currentRotation = group.current.rotation.y;
      
      // Calculate shortest rotation difference
      let rotationDiff = desiredAngle - currentRotation;
      
      // Normalize to [-PI, PI] for shortest path
      if (rotationDiff > Math.PI) rotationDiff -= Math.PI * 2;
      if (rotationDiff < -Math.PI) rotationDiff += Math.PI * 2;
      
      // Apply smooth rotation with lerp
      group.current.rotation.y = currentRotation + rotationDiff * rotationSpeed;
    } else {
      // Reached current waypoint, move to next
      currentPosition.current.copy(targetWaypoint);
      group.current.position.copy(currentPosition.current);
      console.log(`Reached waypoint ${currentWaypoint}/${path.length - 1}`);
      setCurrentWaypoint(prev => prev + 1);
    }
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Sketchfab_Scene">
        <group
          name="Sketchfab_model"
          rotation={[-Math.PI / 2, 0, 0]}
          userData={{ name: 'Sketchfab_model' }}>
          <group
            name="a74ee853e1fb4a2085f5ae30a62c5996fbx"
            rotation={[Math.PI / 2, 0, 0]}
            scale={0.7}
            userData={{ name: 'a74ee853e1fb4a2085f5ae30a62c5996.fbx' }}>
            <group name="Object_2" userData={{ name: 'Object_2' }}>
              <group name="RootNode" userData={{ name: 'RootNode' }}>
                <group name="Object_4" userData={{ name: 'Object_4' }}>
                  <primitive object={nodes._rootJoint} />
                  <skinnedMesh
                    name="Object_7"
                    geometry={nodes.Object_7.geometry}
                    material={materials.material2mat}
                    skeleton={nodes.Object_7.skeleton}
                    userData={{ name: 'Object_7' }}
                  />
                  <group name="Object_6" userData={{ name: 'Object_6' }} />
                  <group name="geometry_0" userData={{ name: 'geometry_0' }} />
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  );
}

// Preload the model
useGLTF.preload('/assets/characters/villager_walking/scene.gltf');
